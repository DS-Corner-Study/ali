# ORM
- Object Relational Mapping. 객체 관계 매핑

- 객체지향 언어에서 의미하는 객체와 RDB의 테이블을 자동으로 매핑하는 방법

- 클래스와 RDB 테이블의 매핑의 불일치를 해결함

- 장점
  
  1. ORM을 사용하면 데이터베이스 쿼리를 객체지향적으로 조작할 수 있음
  2. 재사용 및 유지보수가 편리
  3. 데이터베이스에 대한 종속성이 줄어듬

- 단점
  1. ORM만으로 온전한 서비스를 구현하기에 한계가 있음
  2. 애플리케이션의 객체 관점과 데이터베이스의 관계 관점의 불일치 발생
 
# JPA
- 자바 진영의 ORM 기술 표준으로 채택된 인터페이스의 모음

- JDBC는 SQL에 의존하기 때문에 개발의 효율이 떨어지는데 JPA는 개발자 대신 적절한 SQL을 생성하고 데이터베이스를 조작해서 객체를 자동 매핑

# 하이버네이트
- 자바의 ORM 프레임워크

### Spring Data JPA
- JPA를 편리하게 사용할 수 있도록 지원하는 스프링 하위 프로젝트 중 하나

- CRUD 처리에 필요한 인터페이스를 제공, 엔티티 메니저를 직접 다루지 않고 리포지토리 정의해 적합한 쿼리를 동적으로 생성

# 영속성 컨텍스트
- 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능 수행

- 엔티티 객체가 영속성 컨텍스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영하는 작업 수행

- 영속 객체: 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터 해당 객체를 지칭

  > 애플리케이션 <-> 영속성 컨텍스트 <-> 데이터베이스
  > 
  >   엔티티           영속 객체            데이터

- 엔티티 매니저

    - 엔티티를 관리하는 객체
 
    - 데이터 베이스에 접근해서 CRUD 작업 수행
 
    - 리포지토리에서 엔티티 매니저 사용
 
  - 엔티티의 생명주기
 
       - 비영속: 영속성 컨텍스트에 추가되지 않은 엔티티 객체의 상태를 의미
   
       - 영속: 영속성 컨텍스트에 의해 엔티티 객체가 관리되는 상태
   
       - 준영속: 영속성 컨텍스트에 의해 관리되던 에티티 객체가 컨텍스트와 분리된 상태
   
       - 삭제: 데이터베이스에서 레코드를 삭제하기 위해 영속성 컨텍스트에 삭제 요청 한 상태
   
# 엔티티 관련 기본 어노테이션

- @Entity: 해당 클래스가 엔티티임을 명시하기 위한 어노테이션

- @Table: 클래스 이름과 테이블 이름을 다르게 지정해야 하는 경우 사용

- @Id: 엔티티 클래스의 필드는 테이블의 칼럼과 매핑, id 어노테이션이 선언된 필드가 테이블의 기본값

- @GeneratedValue: 해당 필드의 값을 어떤 방식으로 자동으로 생성할지 결정

- @Column: 엔티티 클래스의 필드는 자동으로 테이블의 칼럼으로 매핑되는데 필드에 몇가지 설정을 할 때 사용


# DAO
- 데이터베이스 로직과 동작 과정에서 데이터를 조작하는 기능을 담당

- Spring Data JPA에서 DAO는 리포지토리가 대체함

- DAO는 서비스 레이어와 리포지토리의 중간 계층을 구성하는 역할

- '인터페이스-구현체' 구성, 의존성 결합을 낮추기 위한 디자인 패턴(서비스 레이어에 DAO 객체를 주입받을 때 인터페이스를 선언하는 방식으로 구성)

- 데이터베이스에 접근하는 메서드는 리턴 값으로 데이터 객체를 전달

     - 객체의 종류: 엔티티 or DTO객체
 
          - 엔티티 객체는 데이터베이스 접근하는 계층에서만 사용하도록 정의 따라서 대른 계층으로 데이터를 전달할 때는 DTO객체 사용

### getById vs findById
- getById: entityManager의 getReference() 메서드 호출 -> 프락시 객체 리턴

- findById: entityManager의 find() 메서드 호출 -> Optional 객체 리턴

# JPA에서 데이터 값 변경
- update 키워드 사용 X

- find() 메서드를 통해 데이터베이스에서 값을 가져오면 그 객체가 영속성 컨텍스트에 추가됨. 그게 유지되는 상황에서 객체의 값을 변경하고 다시 Save() 실행


# 서비스
- 서비스에서는 클라이언트가 요청한 데이터를 적절하게 가공해서 컨트롤러에게 넘기는 역할

- 리턴타입: DTO

  - 서비스 레이어에서 DTO 객체와 엔티티 객체를 각 레이어에 변환해서 전달하는 역할 수행
 
    > 정리: 데이터베이스와 밀접한 관련이 있는 데이터 액세스 레이어까지 -> 엔티티 객체 사용
    >
    > 클라이언트와 가까워지는 다른 레이어 -> DTO 객체 사용
    >
    > 서비스-DAO -> 엔티티
    >

- 서비스 객체 설계 후 비즈니스 로직과 클라이언트의 요처을 연결하는 컨트롤러를 생성해야 함

# 롬복

- 데이터 클래스를 생성할 때 반복적으로 사용하는 getter/setter같은 매서드 어노테이션으로 대체하는 기능을 제공하는 라이브러리

# 동등성과 동일성
- 동등성: 비교 대상이 되는 두 객체가 가진 값이 같음

- 동일성: 두 객체가 같은 객체
- 




















